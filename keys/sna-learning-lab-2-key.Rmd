---
title: 'Network Measures & Sociograms'
subtitle: 'SNA Learning Lab 2'
author: "LASER Institute"
date: "`r format(Sys.Date(),'%B %e, %Y')`"
output:
  html_document:
    toc: yes
    toc_depth: 5
    toc_float: yes
bibliography: lit/references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## EXPLORE

As noted in the Getting Started Walkthrough, exploratory data analysis involves the processes of describing your data (such as by calculating the means and standard deviations of numeric variables, or counting the frequency of categorical variables) and, often, visualizing your data prior to modeling.

In Learning Lab 2, we pickup right where we left off with our data wrangling. We'll learn some new functions for retrieving basic network descriptives related to our research question and use some of these metrics to create and refine a network visualization that helps illustrate key findings. Specifically, in this section we'll learn to:

a.  **Examine Basic Descriptives**. We focus primarily on actors and edges in this walkthrough, including the edges wights we added in the previous section as well as node degree, and import and fairly intuitive measure of centrality.

b.  **Make a Sociogram**. Finally, we wrap up the explore phases by learning to plot a network and tweak key elements like the size, shape, and position of nodes and edges to better at communicating key findings.

Before we explore, we'll need to reload our libraries from the previous lab and rebuild our network object.

#### [**Your Turn**]{style="color: green;"} **⤵** {style="caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-style: normal; font-variant-caps: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; text-decoration: none;"}

In the code chunk below, add comments following the `#` symbol used for commenting code that provides a brief description of the function of the lines of code that follow each hashtag:

```{r}
# Load Packages
library(tidyverse) 
library(here) 
library(igraph)

# Import Data

ties <- read_csv(here("data", "dlt1-edgelist.csv"))
                 
actors <- read_csv(here("data", "dlt1-nodes.csv"))

# Create an igraph graph or network object
network <- graph_from_data_frame(d = ties, 
                                 vertices = actors, 
                                 directed = T) 

# Add a "weight" of 1 to each edge in network
E(network)$weight <- 1  

# Remove duplicate edges and loops and add weights for each dyad
weighted_network <- simplify(network,
                             edge.attr.comb = list(weight="sum")
                             )

# View Network
weighted_network
```

**RStudio Tip:** We have another reason for reviewing and running our code from the previous lab. Each R Markdown document is a self-contained file. In order to be able to knit a share a markdown file, all code required to run an analysis must be present in the document even if those objects and packages are loaded and save in your environment.

### Examine Basic Descriptives

Many analyses of social networks are primarily descriptive. As Carolyn (2013) notes, these descriptive studies aim either to represent the network's underlying social structure through data-reduction techniques or to characterize network properties through network measures.

#### Node Degree

A key structural property of networks is the concept of centralization. A network that is highly centralized is one in which relations are focused on a small number of actors or even a single actor in a network, whereas ties in a decentralized network are diffuse and spread over a number of actors. One of the most common descriptives reported in network studies and a primary measure of centralization is **degree**.

> Degree is the number of ties to and from an ego. In a directed network, in-degree is the number of ties received, whereas out-degree is the number of ties sent.

The {igraph} package has an aptly named function `degree()` for retrieving degree, in-degree, and out-degree for all actors in a network.

Run the following code to extract measures and save to `node_degree` which we'll examine in just a bit:

```{r}
node_degree <- degree(weighted_network, mode = "all")
```

**Note**. We set the `mode =` argument in this function to "all" which give us the total number of participants that each actor in our network sent or received a reply.

Let's take a look at the distribution of `node_degree` in our network by using R's built in `hist()` function for creating histograms. I set the value of `breaks =`, or bins in our histogram, to 30 since I already know some actors in this network have a very high degree.

```{r}
hist(node_degree, breaks = 30)
```

We can see that most actors in the network are connected to very few individuals while a couple actors in this network are connected to a very larger number, nearly 200 and 350 respectively!

Now let's take a look at the mean and median for `node_degree` using some other {base} R functions:

```{r}
mean(node_degree)
median(node_degree)
```

We see that the mean suggests the participants are, on average, connected to about 8 other participants in the MOOC-Ed, but this is likely heavily skewed by the two individuals with a disproportionate number of connections. The median is probably a better characterization of the typical number of educators a participant has sent or received a reply.

##### In-Degree

Let's go ahead and take a look at in-degree next:

```{r}
in_degree <- degree(weighted_network, mode="in")

hist(in_degree, breaks = 30)
mean(in_degree)
median(in_degree)
```

Again, most participants received a reply from small number of individuals.

#### [**Your Turn**]{style="color: green;"} **⤵** {style="caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-style: normal; font-variant-caps: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; text-decoration: none;"}

Use the code chunk below to examine the distribution, mean and median of `out_degree`:

```{r}
out_degree <- degree(weighted_network, mode="out")

hist(out_degree, breaks = 30)
mean(out_degree)
median(out_degree)
```

In the space below, write your interpretation of these results.

-   YOUR RESPONSE HERE

#### Edge Weights

Finally, let's also take a look at the distribution, mean and median of the edge weights we added to our graph.

Recall from earlier that the {igraph} package has a unique syntax for accessing node and edge attributes. For edges we use `E()` and included the name of the network object we want to use, followed by the `$` operator to select the attribute.

```{r}
weights <- E(weighted_network)$weight

hist(weights, breaks = 10)
mean(weights)
median(weights)
```

It looks like the vast majority or participants either sent or received a reply from just one other participant.

#### [**Your Turn**]{style="color: green;"} **⤵** {style="caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-style: normal; font-variant-caps: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; text-decoration: none;"}

The use of the `$` is actually standard across R and a very useful operator.

Use the code chunk below to create a histogram and calculate the mean and median from the edge weighs created earlier in the [Add Edge Weights] section by using the `edge_weights` data frame, the `$` operator, and column `n` which contains the counts for each unique edge.

```{r}
mean(edge_weights$n)
median(edge_weights$n)
```

Are these results consistent with our summary of edge weights we created above?

-   YOUR RESPONSE HERE

## Make a Sociogram

If you recall from our Learning Lab 1, one of the defining characteristics of the social network perspective is its use of graphic imagery to represent actors and their relations with one another. To emphasize this point, Carolyn (2013) reported that:

> The visualization of social networks has been a core practice since its foundation more than 90 years ago and remains a hallmark of contemporary social network analysis. 

Network visualization can be used for a variety of purposes, ranging from highlighting key actors to even serving as works of art. This excellent figure from Katya Ognyanova's also excellent tutorial on [Static and Dynamic Network Visualization with R](https://kateto.net/network-visualization/) helps illustrate the variety of goals a good network visualization can accomplish:

![](img/viz-goals.jpeg){width="80%"}

These visual representations of the actors and their relations, i.e. the network, are called a sociogram. Actors who are most central to the network, such as those with higher node degrees, are usually placed in the center of the sociogram and their ties are placed near them. As we'll see in just a bit, those two actors with hundreds of ties will be placed by most graph layout algorithms in the center of the graph.

For this lab, we'll be using the `plot()` function from R's built in {graphics} package to make a sociogram.

Let's run the code and see what we get without any tweaking and see what the plot function produces:

```{r}
plot(weighted_network)

```

Yikes! That's not very helpful!!

If this had been a smaller network like one generated from a teacher professional development workshop, this might have been useful, but for large networks like our MOOC-Ed discussion forums, this doesn't communicate much. In fact, it's visualizations like these that give sociograms the unflattering nickname of "hair ball" plots.

Fortunately, the {igraph} package includes a [plethora of plotting parameters](https://igraph.org/r/doc/plot.common.html) for improving the layout and visual design of network graphs!

There are many ways to modify vertices and edges in a sociogram to improve readability. Up to four attributes of each actor can be layered onto the sociogram by altering the color, shape, label, and size of the symbol. And attributes for edges can be represented in a range of ways as well.

### Remove Labels

One quick fix is to simply remove the labels by adding the `vertex.label =` argument and setting it to `NA`.

Since the number labels don't provide much useful information, let's go ahead and remove them:

```{r}
plot(weighted_network,
     vertex.label = NA)
```

We can now at least see the nodes, or vertices, but with 445 participants in the forums, many are masked by the default size of each node.

### Change vertex size

By default, the size of nodes is 15. Let's add the `vertex.size =` argument and change that to 1:

```{r}
plot(weighted_network,
     vertex.label = NA,
     vertex.size = 1)
```

A little better, but let's use the `node_degree` we calculated to emphasize those with greater connections in the course by substitute `node_degree` for a specific value.

```{r}
plot(weighted_network,
     vertex.label = NA,
     vertex.size = node_degree)
```

Whoops! This certainly emphasizes the disproportionate number of ties among these two participants, but not quite what we're going for.

Since `node_degree` is just a list of values for each node we can treat it like a number. Let's divide that by 10 to reduce the relative size:

```{r}
plot(weighted_network,
     vertex.label = NA,
     vertex.size = node_degree/10)
```

That's better, and helps highlight our two main actors without overshadowing the rest, but those arrows are definitely an eyesore.

### Reduce arrow size

Let's add the `edge.arrow.size =` argument and dramatically reduce:

```{r}
plot(weighted_network,
     vertex.label = NA,
     vertex.size = node_degree*.1,
     edge.arrow.size = .04)
```

Much better, now let's deal with the size of the edges.

#### Adjust Edge Width

We can add the `edge.width =` argument to help minimize edge overlap yet still make them visible. This is a bit of trial and error but let's give .2 a try since the default is 1:

```{r}
plot(weighted_network,
     vertex.label = NA,
     vertex.size = node_degree*.05,
     edge.arrow.size = .04,
     edge.width = .2)
```

Note that we could also set `edge.with =` to the weight of each edge, similar to how we used degree for the size of each node.

Let's give that a try:

```{r}
plot(weighted_network,
     vertex.label = NA,
     vertex.size = node_degree*.1,
     edge.arrow.size = .04,
     edge.width = E(weighted_network)$weight)
```

Not much of an improvement, if at all, given how many edges are in our network.

Let's try dividing that weight by 5 similar to reduce like with did with the `vertex.size =` argument:

```{r}
plot(weighted_network,
     vertex.label = NA,
     vertex.size = node_degree*.05,
     edge.arrow.size = .05,
     edge.width = E(weighted_network)$weight/5)
```

Better, but since we know most edges have a weight of 1 there really isn't too much to work with here.

Let's move on to changing graph layout!

## MODEL

As highlighted in [Chapter 3 of Data Science in Education Using R](https://datascienceineducation.com/c03.html), the **Model** step of the data science process entails "using statistical models, from simple to complex, to understand trends and patterns in the data." The authors note that while descriptive statistics and data visualization during the **Explore** step can help us to identify patterns and relationships in our data, statistical models can be used to help us determine if relationships, patterns and trends are actually meaningful.

### Graph Layout Algorithms

One of the major advances in visualization since the first hand-drawn sociograms developed by Jacob Moreno (1934) to represent relations among children in school is the use of software and algorithms to automatically layout networks on a grid.

There are many different [layout methods and models](https://en.wikipedia.org/wiki/Graph_drawing#Layout_methods) for sociograms, but we'll start with the Fruchterman-Reingold (FR) layout, which is one of the most used layout algorithms for network visualization. These types of force-directed algorithms generally work well with large networks and try to layout graphs in "an aesthetically-pleasing way" by making edges roughly equal in length and minimizing overlap.

Let give the FR layout a try by using the `layout =` argument and specifying `layout_with_fr`:

```{r}
plot(weighted_network,
     vertex.label = NA,
     vertex.size = node_degree*.05,
     edge.arrow.size = .05,
     edge.width = E(weighted_network)$weight/5,
     layout = layout_with_fr)
```

By default, {igraph} uses `layout_nicely`, a smart function that chooses a layout based on the graph. Given the similarity with our previous graph, I'm assuming it chose the the FR layout as well.

Let's try one more just for fun:

```{r}

plot(weighted_network,
     vertex.label = NA,
     vertex.size = node_degree*.05,
     edge.arrow.size = .05,
     edge.width = E(weighted_network)$weight/5,
     layout = layout_in_circle)

```

Interesting but not terribly useful!

There are many other [igraph layout functions](https://igraph.org/r/doc/layout_.html), some more useful than others depending on the context. We've only scratched the surface of what's possible with network plotting but hopefully this have given you a sense of what required to avoid the dreaded "hair ball" plot and create a network viz that communicates something useful.

#### [**Your Turn**]{style="color: green;"} **⤵** {style="caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-style: normal; font-variant-caps: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; text-decoration: none;"}

Try modifying the code below by tweaking the included arguments/parameters or [adding new arguments/parameters](https://igraph.org/r/doc/plot.common.html) to make our plot either more "aesthetically pleasing" or more purposeful in what it's trying to communicate.

There are no right or wrong answers, just have some fun trying out different approaches!

```{r}
plot(weighted_network,vertex.label = NA,
     vertex.size = node_degree*.05,
     edge.arrow.size = .05,
     edge.width = E(weighted_network)$weight/5,
     layout = layout_with_fr)
```

### Other Applications of Models in SNA

We will not explore the use of models for SNA , but recall from A Social Network Perspective in MOOC-Edswas guided by the following questions:

1.  What are the patterns of peer interaction and the structure of peer networks that emerge over the course of a MOOC-Ed?

2.  To what extent do participant and network attributes (e.g., homophily, reciprocity, transitivity) account for the structure of these networks?

3.  To what extent do these networks result in the co-construction of new knowledge?

To address Question 1, actors in the network were categorized into distinct mutually exclusive groups using the core-periphery and regular equivalence functions of UCINET. The former used the CORR algorithm to divide the network into actors that are part of a densely connected subgroup, or "core", from those that are part of the sparsely connected periphery. Regular equivalence employs the REGE blockmodeling algorithm to partition, or group, actors in the network based on the similarity of their ties to others with similar ties. In essence, blockmodeling provides a systematic way for categorizing educators based on the ways in which they interacted with peers.

As we saw upon just a basic visual inspection of our network during the Explore section, there was a small core of highly connected participants surrounded by those on the "periphery," or edge, of the network with very few connections. In the DLT 2 course, those on the periphery made up roughly 90% of network! The study also found relatively high levels of reciprocation, but also found that roughly a quarter of participants were characterized as "brodcasters" -- educators who initiated a discussion thread, but neither reciprocated with those who replied, nor posted to threads initiated by others.

To address Question 2, this study use the exponential family of random graph models (ERGM; also known as p\* models), which provide a statistical approach to network modeling that addresses the complex dependencies within networks. ERGMs predict network ties and determine the statistical likelihood of a given network structure, based on an assumed dependency structure, the attributes of the individuals (e.g., gender, popularity, location, previous ties) and prior states of the network.

#### [**Your Turn**]{style="color: green;"} **⤵** {style="caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-style: normal; font-variant-caps: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; text-decoration: none;"}

Recall from SNA Learning Lab 1 that you were asked to identify two "node attributes" from the dataset that might be useful for predicting participants who may be more engaged or central to the network.

Take look at page 276 of [A social network perspective on peer supported learning in MOOCs for educators](https://github.com/sbkellogg/eci-589/blob/main/unit-1/lit/sna_mooc_irrodl_bjet_articles.pdf). Were your predictions correct?

-   YOUR RESPONSE HERE

## COMMUNICATE

In this learning lab, we focused on gaining some context about our data; learning how to wrangle network data structures; and examining basic but important network descriptives such as network size, node degree and edge weights.. Below, add a few notes in response to the following prompts.

One thing I took away from this learning lab:

-   YOUR RESPONSE HERE

One thing I want to learn more about:

-   YOUR RESPONSE HERE

If you wanted, you could save the processed data set to your data folder. The `write_csv()` function is useful for this. The following code is set to not run, as we wanted to ensure that everyone had the data set needed to begin the second learning lab, but if you're confident in your prepared data, you can save it with the following:

```{r, eval = FALSE} write_csv(time_spent, "data/time_spent_hours.csv")}
```

Congratulations - you've completed the first network analysis learning lab! To complete your work, you can click the drop down arrow at the top of the file, then select "Knit top HTML". This will create a report in your Files pane that serves as a record of your code and its output you can open or share.

## Reach (Optional)

For this learning lab, your reach is to prepare a network graph object using either your own data or data from second MOOC-Ed course iteration of the *The Digital Learning Transition in K-12 Schools*. Note, this data is also included in your data folder but can be downloaded from [Harvard Dataverse](https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/ZZH3UB) as well.

Please (optionally) start on this work right here, including reading data, preparing it, and then creating a faceted plot using data of your choosing. If you do this, re-knit your document when complete or at a stopping point so you have a record of your work!

```{r}
ties_2 <- read_csv(here("data", "dlt2-edgelist.csv"))
                 

actors_2 <- read_csv(here("data", "dlt2-nodes.csv"))

network_2 <- graph_from_data_frame(d = ties_2, 
                                 vertices = actors_2, 
                                 directed = T) 

E(network_2)$weight <- 1  

weighted_network_2 <- simplify(network_2,
                             edge.attr.comb = list(weight="sum")
                             )

weighted_network_2
```

Another option is to click "Tutorial" in the top right corner of your RStudio window and to begin one of the {learnr} tutorials. If you start one of these, take a note on this work here as a record of what you've began.

### 🧶 Knit & Check ✅

Congrats! You made it to the end of the SNA Learning Lab 2 and are ready to learn a little about network modeling! Before proceeding further, knit your document and check to see if you encounter any errors.

### 🧗🏾‍ Reach & Read 📚

Now that you've finished your first SNA Learning Lab,

#### Independent Practice

You're also welcome to try out some of the other graphing options from from Katya Ognyanova's tutorial on [Static and Dynamic Network Visualization with R](https://kateto.net/network-visualization/).

#### Readings and Resources

Also, you may be interested in further exploring the following books, articles and resources cited in this lab:
