---
title: "SNA Case Study: Who's Friends with Who in Middle Schools"
subtitle: "LASER Institute Learning Lab 1"
author: "Dr. Shaun Kellogg"
date: "`r format(Sys.Date(),'%B %e, %Y')`"
output:
  html_document:
    toc: yes
    toc_depth: 4
    toc_float: yes
    code_folding: show
    code_download: TRUE
editor_options:
  markdown:
    wrap: 72
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

## 1. PREPARE

Our first SNA case study is guided by the work of Matthew Pittinsky and
Brian V. Carolan (2008), which employed a social network perspective to
examine teachers perceptions of student friendships agreed with their
own. Sadly, this excellent study did not include any visual depictions
comparing student and teacher perceived friendship networks, but we are
going to fix that!

Our primary aim for this case study is to gain some hands-on experience
with essential R packages and functions for preparing network data for
analysis and creating a simple network sociogram to help describe
visually what our network "looks like." Specifically, this case study
will cover the following topics pertaining to each data-intensive
workflow process [@krumm2018]:

1.  **Prepare**: Prior to analysis, we'll take a look at the context
    from which our data came, formulate some research questions, and get
    introduced the {tidygraph} and {ggraph} packages for analyzing and
    visualizing relational data.

2.  **Wrangle**: In the wrangling section of our case study, we will
    learn some basic techniques for manipulating, cleaning,
    transforming, and merging network data.

3.  **Explore**: With our network data tidied, we learn to calculate
    some key network measures and to illustrate some of these stats
    through network visualization.

4.  **Model**: We conclude our analysis by introducing community
    detection algorithms for identifying groups and revisiting sentiment
    about the common core.

5.  **Communicate**: We develop a polished sociogram to highlight key
    findings.

### 1a. Review the Research

![](img/pittinsky-carolan.png){width="50%"}

Pittinsky, M., & Carolan, B. V. (2008). Behavioral versus cognitive
classroom friendship networks.Â *Social Psychology of
Education*,Â *11*(2), 133-147.

#### Abstract

Researchers of social networks commonly distinguish between "behavioral"
and "cognitive" social structure. In a school context, for example, a
teacher's perceptions of student friendship ties, not necessarily actual
friendship relations, may influence teacher behavior. Revisiting early
work in the field of sociometry, this study assesses the level of
agreement between teacher perceptions and student reports of
within-classroom friendship ties. Using data from one middle school
teacher and four classes of students, the study explores new ground by
assessing agreement over time and across classroom social contexts, with
the teacher-perceiver held constant. While the teacher's perceptions and
students' reports were statistically similar, 11--29% of possible ties
did not match. In particular, students reported significantly more
reciprocated friendship ties than the teacher perceived. Interestingly,
the observed level of agreement varied across classes and generally
increased over time. This study further demonstrates that significant
error can be introduced by conflating teacher per- ceptions and student
reports. Findings reinforce the importance of treating behavioral and
cognitive classroom friendship networks as distinct, and analyzing
social structure data that are carefully aligned with the social process
hypothesized.

#### Research Questions

The central question guiding this investigation was:

> Do student reports agree with teacher perceptions when it comes to
> classroom friendship ties and with what consequences for commonly used
> social network measures?

We will be using this question to guide our own analysis of the
classroom friendships reported by teachers. Specifically, we will use
the first part of this question to guide our analysis and develop two
sociograms to help visually compare similarities and differences between
teacher and student reported classroom friendships.

#### Data Collection

To measure the level of agreement between student and teacher reports of
classroom student friendships, sociometric data were collected from each
student in all four classes and the teacher provided similar reports on
all students. To collect student reports of friendships, students were
given a class roster and asked to describe their relationship with each
student in the class. Choices included best friend, friend, know-like,
know, know-dislike, strongly dislike, and do not know. In the
terminology of network analysis, these sociometric data are "valued"
(degrees of friendship, not just yes or no) and "directed" (friendship
nominations were not presumed to be reciprocal). Data were collected in
the autumn and spring. All "best friend" and "friend" choices are coded
as '1' (friend), while all other choices are coded as '0' (not friend).
The teacher's reports of students' friendships were generated in a
similar manner.

#### Analyses		

To assess agreement between perceived friendship by the teacher and
students, QAP (quadratic assignment procedure) correlations for each
class's two matrices (teacher and student generated) were analyzed in
the autumn andspring. A QAP correlation is used to calculate the degree
of association between two sets of relations; it tests whether the
probability of dyad overlap in the teacher matrix is correlated with the
probability of dyad overlap in the student matrix. It does so by running
a large number of simulations. These simulations generate random
matrices with sizes and value distributions based on the original two
matrices being tested. It then computes an average level of correlation
between the matrices that would be expected at random. Similarly, it
calculates the probability that the observed degree of correlation
between two matrices would be as large or as small as that observed
based on the range of correlations generated in the random permutations,
with an associated significance statistic.

#### Key Findings

As reported by @pittinsky2008behavioral in their findings section:

> While the teacher's perceptions and students' reports were
> statistically similar, 11--29% of possible ties did not match. In
> particular, students reported significantly more reciprocated
> friendship ties than the teacher perceived.

#### **ðŸ‘‰ Your Turn** **â¤µ**

Take a look at the paper in our essential readings repository on GitHub
and

-   

## 1b. Identify a Question(s)

Recall from above that the central question guiding the #COMMONCORE
Project was:

> How are social media-enabled social networks changing the discourse in
> American politics that produces and sustains education policy?

For Unit 4, we are going to focus our questions on something a bit less
ambitious but inspired by this work:

1.  Who are the transmitters, transceivers, and transcenders in our
    Common Core Twitter network?
2.  What subgroups, or factions, exist in our network?
3.  Which actors in our network tend to be more opposed to the Common
    Core?

To address the last question, we'll revisit our techniques we learned
from our Unit 3 VADER sentiment analysis.

### **ðŸ‘‰ Your Turn** **â¤µ**

Based on what you know about networks and the context so far, what other
research question(s) might ask we ask in this context that a social
network perspective might be able to answer?

In the space below, type a brief response to the following questions:

-   YOUR RESPONSE HERE

## 1c. Set Up Project

As highlighted inÂ [Chapter 6 of Data Science in Education Using
R](https://datascienceineducation.com/c06.html)Â (DSIEUR), one of the
first steps of every workflow should be to set up your "Project" within
RStudio. Recall that:

> A **Project** is the home for all of the files, images, reports, and
> code that are used in any given project

Since we are working in RStudio Cloud, a Project has already been set up
for you as indicated by the `.Rproj` file in your main directory in the
Files pane.

### Load Libraries

In Unit 1, we also learned about **packages**, or libraries, which are
shareable collections of R code that can contain functions, data, and/or
documentation and extend the functionality of R. You can always check to
see which packages have already been installed and loaded into RStudio
Cloud by looking at the the Files, Plots, & Packages Pane in the lower
right hand corner.

### **ðŸ‘‰ Your Turn** **â¤µ**

First, load the {tidyverse}, {tidytext} and {vader} packages from
previous case studies. We'll be using several of these packages to
wrangling and explore our data later sections:

```{r}
library(tidyverse)
library(tidytext)
library(vader)
```

Next, we will introduce a few new packages that will help us with our
social network analyses.

### tidygraph ðŸ“¦

![](img/tidygraph.png){width="20%"}

The {[tidygraph](https://tidygraph.data-imaginist.com)} package is a
huge package that exports 280 different functions and methods, including
access to almost all of theÂ `dplyr`Â verbs plus a few more, developed for
use with relational data. While network data itself is not tidy, it can
be envisioned as two tidy tables, one for node data and one for edge
data. The {tidygraph} package provides a way to switch between the two
tables and uses `dplyr` verbs to manipulate them. Furthermore it
provides access to a lot of graph algorithms with return values that
facilitate their use in a tidy workflow.

Let's go ahead and load the {tidygraph} library:

```{r}
library(tidygraph)
```

### ggraph ðŸ“¦

![](img/ggraph.png){width="20%"}

Created by the same developer as {tidygraph},
{[ggraph](https://ggraph.data-imaginist.com/index.html)} -- pronounced
gg-raph or g-giraffe hence the logo -- is an extension of
{[ggplot](https://ggplot2.tidyverse.org)} aimed at supporting relational
data structures such as networks, graphs, and trees. Both packages are
more modern and widely adopted approaches data visualization in R.

While ggraph builds upon the foundation of ggplot and its API, it comes
with its own self-contained set of geoms, facets, etc., as well as
adding the concept ofÂ *layouts*Â to the [grammar of
graphics](https://ggplot2-book.org/introduction.html?q=grammar#what-is-the-grammar-of-graphics),
i.e. the "gg" in ggplot and ggraph.

Let's go ahead and load the {ggraph} library:

```{r}
library(ggraph)
```

### igraph Package **ðŸ“¦**

![](img/igraph.png){width="20%"}

Both {tidygraph} and {ggraph} depend heavily [igraph network analysis
package](https://igraph.org). The main goals of the igraph package and
the collection of network analysis tools it contains are to provide a
set of data types and functions for:

1.  pain-free implementation of graph algorithms,

2.  fast handling of large graphs, with millions of vertices (i.e.,
    actors or nodes) and edges,

3.  allowing rapid prototyping via high level languages like R.

Run the code chunk below to load the {igraph} library:

```{r}
library(igraph)
```

### Import Data

Finally, we'll be using a fresh data download from twitter that only
includes relatively small set of tweets from the past week to help keep
things simple. Network graphs can quickly get unwieldy as the nodes in
your network grow. The #commoncore project does an excellent job
visualizing large networks using advanced techniques. We'll focus on a
relatively small network since we'll be introduce some very basic
techniques for visualization.

Run the following code to use the `read_csv()` function from the {readr}
package to read the `ccss-tweets-fresh.csv` file from the data folder
and assign to a new data frame named `ccss_tweets`:

```{r}
ccss_tweets <- read_csv("data/ccss-tweets-fresh.csv")
```

------------------------------------------------------------------------

# 2. WRANGLE

In general, data wrangling involves some combination of cleaning,
reshaping, transforming, and merging data [@wickham2016r]. As
highlighted in @estrellado2020e, wrangling network data can be even more
challenging than other data sources since network data often includes
variables about both individuals and their relationships.

For our data wrangling this week, we're keeping it simple since working
with relational data is a bit of a departure from our working with
rectangular data frames. Our primary goals for Unit 1 are learning how
to:

a.  **Create an Edgelist**. In this section, we introduce a new tidy
    data format call the "edgelist" which contains information about
    each edge (i.e. connections or ties between actors) in our network.

b.  **Format Network Data**. We learn to shape our data files into two
    common formats for storing network data: edgelists and nodelists.

c.  **Create a Network Object**. Finally, we'll need to convert our data
    frames into special data format, an R network object, for working
    with relational data.

## 2b. Format Network Data

Recall from Chapter 1 of @carolan2014 that ties, or relations, are what
connect actors to one another. These ties are often referred to as
"edges" when formatting and graphing network data and the range of ties
in a network can be extensive. Some of the more common ties, or edges,
used to denote connections among actors in educational research include:

-   Behavioral interaction (e.g., talking to each other or sending
    messages)

-   Physical connection (e.g., sitting together at lunch, living in the
    same neighborhood)

-   Association or affiliation (e.g., taking the same courses, belonging
    to the same peer group)

-   Evaluation of one person by another (e.g., considering someone a
    friend or enemy)

-   Formal relations (e.g., knowing who has authority over whom)

-   Moving between places or status (e.g., school choice preferences,
    dating patterns among adolescents)

### Create Edgelist

The **edgelist** format is slightly different than other formats you
have likely worked with in that the values in the first two columns of
each row represent a dyad, or tie between two nodes in a network. An
edge-list can also contain other information regarding the strength,
duration, or frequency of the relationship, sometime called weight, in
addition to other "edge attributes."

For our analysis of tweets in this case study, we'll use an approach
similar to that used by @supovitz2017commoncore. Specifically, each node
is an individual Twitter user (person, group, institution, etc.) and the
connection between each node is the tweet, retweet, or mention/reply.

### **ðŸ‘‰ Your Turn** **â¤µ**

Use the code chunk below to look at the data we just imported using one
of your favorite methods for inspecting data. In the space that follows,
identify the columns you think could be used to construct an edge list.

```{r, eval=FALSE}
view(ccss_tweets)
```

-   YOUR RESPONSE HERE

#### Extract Edges and Nodes

If one of the columns you indicated in your response above included
`screen_name` nice work! You may also have noticed that the
`mentions_screen_name` column includes the names of those in the reply
column, as well as those "mentioned" in each tweet, i.e. whose username
was included in a post.

As noted above, an edgelist includes the nodes that make up a tie or
dyad. Since the only two columns we need to construct our edgelist is
the `screen_name` of the tweet author and the screen names of those
included in the mentions, let's:

1.  `relocate()` and rename those columns to `sender` and `target` to
    indicate the "direction" of the tweet;

2.  `select()` those columns along with any attributes that we think
    might be useful for analysis later on, like the timestamp or content
    of the tweet, i.e. `text`;

3.  assign our new data frame to `ties_1`.

```{r}
ties_1 <-  ccss_tweets %>%
  relocate(sender = screen_name, # rename scree_name to sender
           target = mentions_screen_name) %>% # rename to receiver
  select(sender,
         target,
         created_at,
         text)

ties_1
```

Our edgelist with attributes is almost ready, but we have a couple of
issues we still need to deal with.

As you may have noticed, our receiver column contains the names of
multiple Twitter users, but a dyad or tie can only be between two actors
or nodes.

#### "Unnest" User Names

In order to place each target user in a separate row that corresponds
with each sender of the tweet, we will need to "unnest" these names
using the {tidytext} package from Unit 3.

In Unit 3 we used the `unnest_tokens()` function to extract individual
words from tweets. This time we'll use it to place target of each tweet
into separate rows corresponding to the sender of each tweet.

Run the following code and take a look at the new data frame to make
sure it looks as expect and to spot any potential issues:

```{r}
ties_2 <- ties_1 %>%
  unnest_tokens(input = target,
                output = receiver,
                to_lower = FALSE) %>%
  relocate(sender, receiver)

ties_2
```

You probably notice one issue that we could deal with in a couple
different ways. Specifically, many tweets are not directed at other
users and hence the value for receiver is *`NA`*. We could keep these
users as "isolates" in our network, but let's simply remove them since
our primary goal is to identify transmitters, transceivers and
transcenders.

### **ðŸ‘‰ Your Turn** **â¤µ**

In the code chunk below, use the `drop_na()` function to remove the rows
with missing values from our `receiver` column in our `ties-2` data
frame since they are incomplete dyads. Save your final edgelist as
`ties` using the `<-` assignment operator.

```{r}
ties <- ties_2 %>%
  drop_na(receiver)
```

Now use the code chunk below to take a quick look at our final edgelist
and answer the questions that follow:

```{r, eval=FALSE}
ties
```

1.  How many edges are in our CCSS network?

    -   YOUR RESPONSE HERE

2.  What do these ties/edges/connections represent?

    -   YOUR RESPONSE HERE

3.  When do they start and end?

    -   YOUR RESPONSE HERE

### Create Nodelist

The second file we need to create is a data frame that contains all the
nodes, often referred to as actors, in our network. This list sometimes
includes attributes that we might want to examine as part of our
analysis as well, like the number of Twitter followers, demographic
group, country, gender, etc. This file or data frame is sometimes
referred to as a **nodelist** or node attribute file.

To construct our basic nodelist, we will use the `pivot_longer()`
function from the {dplyr} package, an updated version of the `gather()`
function introduced in the [RStudio Reshape Data
Primer](https://rstudio.cloud/learn/primers/4.1).

Run the following code to select the usernames form our `ties` edgelist,
merge our sender and receiver columns into a single column, and take a
quick look at our new data frame.

```{r}
actors_1 <- ties %>%
  select(sender, receiver) %>%
  pivot_longer(cols = c(sender,receiver))

actors_1
```

As you can see, our sender and receiver usernames have been combined
into a single column called `value` with a new column indicating whether
they were a sender or receiver called `name` by default.

Since we're only interested in usernames for our nodelist, and since we
have a number of duplicate names, let's select just the `value` column,
rename it to actors, and use the `distinct()` function from {dplyr} to
keep only unique names and remove duplicates:

```{r}
actors <- actors_1 %>%
  select(value) %>%
  rename(actors = value) %>% 
  distinct()
```

### **ðŸ‘‰ Your Turn** **â¤µ**

Use the code chunk below to take a quick look at our final `actors` data
frame and answer question that follows:

```{r, eval=FALSE}
actors
```

How many unique node/actors are in our CCSS network?

-   YOUR RESPONSE HERE

## 2c. Create Network Object

Before we can begin using many of the functions from the {tidygraph} and
{ggraph} packages for summarizing and visualizing our Common Core
Twitter network, we first need to convert our node and edge lists into
network object.

### Combine Edges & Nodes

The {tidygraph} package contains a `tbl_graph()` function that includes
the following arguments:

-   `edges =` expects a data frame, in our case `ties`, containing
    information about the edges in the graph. The nodes of each edge
    must either be in a `to` and `from` column, or in the two first
    columns like the data frame we provided.

-   `nodes =` expects a data frame, in our case `actors`, containing
    information about the nodes in the graph. If `to` and/or `from` are
    characters or names, like in our data frames, then they will be
    matched to the column named according to `node_key` in nodes, if it
    exists, or matched to the first column in the node list.

-   `directed =` specifies whether the constructed graph should be
    directed, i.e. include information about whether each node is the
    sender or target of a connection. By default this is set to `TRUE`.

Let's go ahead and create our network graph, name it `network` and print
the output:

```{r}
ccss_network_1 <- tbl_graph(edges = ties, 
                            nodes = actors)

ccss_network_1
```

### **ðŸ‘‰ Your Turn** **â¤µ**

Take a look at the output for our simple graph above and answer the
following questions:

1.  Are the numbers and names of nodes and actors consistent with our
    `actors` and `ties` data frames? What about the integers included in
    the `from` and `to` columns of the Edge Data?

    -   YOUR RESPONSE HERE

2.  What do you think "components" refers to? **Hint:** see Chapter 6 of
    [@carolan2014].

    -   YOUR RESPONSE HERE

3.  Is our network directed or undirected?

    -   YOUR RESPONSE HERE

A quick note about "directed" networks. A **directed network** indicates
that a connection or tie is not necessarily reciprocated or mutual. For
example, our network is directed because even though a user may follow,
mention or reply to someone else, they may not necessarily receive a
follow, mention or reply back. A facebook friendship network is
undirected, however, since someone can not "friend" someone on Facebook
without them also indicating a "friend" relationship, so the friendship
is mutual or reciprocated.

------------------------------------------------------------------------

# 3. EXPLORE

As noted in in our course readings, exploratory data analysis involves
the processes of describing your data (such as by calculating the means
and standard deviations of numeric variables, or counting the frequency
of categorical variables) and, often, visualizing your data prior to
modeling.

In Section 3, we use the {tidygraph} package for retrieving network
descriptives and introduce the {ggraph} package to create a network
visualization to help illustrate these metrics. Specifically, in this
section we'll learn to:

a.  **Examine Basic Descriptives**. We focus primarily on actors and
    edges in this walkthrough, including the edges wights we added in
    the previous section as well as node degree, and import and fairly
    intuitive measure of centrality.

b.  **Make a Sociogram**. Finally, we wrap up the explore phases by
    learning to plot a network and tweak key elements like the size,
    shape, and position of nodes and edges to better at communicating
    key findings.

## 3a. Examine Basic Descriptives

Many analyses of social networks are primarily descriptive. As
@carolan2014 notes, these descriptive studies aim either to:

1.  represent the network's underlying social structure through
    data-reduction techniques; or,

2.  characterize network properties through network measures.

### Centrality

A key structural property of networks is the concept of centralization.
A network that is highly centralized is one in which relations are
focused on a small number of actors or even a single actor in a network,
whereas ties in a decentralized network are diffuse and spread over a
number of actors. One of the most common descriptives reported in
network studies and a primary measure of centralization is **degree**.

> **Degree** is the number of ties to and from an ego. In a directed
> network, in-degree is the number of ties received, whereas out-degree
> is the number of ties sent.

#### Node Degree

The {tidygraph} package has an unique function called `activate()` that
allows us to treat the nodes in our network object as if they were a
typical data frame to which we can then apply standard tidyverse
functions like `select()`, `filter()`, and `mutate()`.

The latter function, `mutate()`, we can use to create new variables for
nodes such as measures of degree, in-degree, and out-degree used by
@supovitz2017commoncore to identify transcenders, tranceivers, and
transmitters respectively. These measures can be added by using the
`centrality_degree()` function in the {tidygraph} package.

Run the following code to add degree measures to each of our nodes and
print the output for inspection:

```{r}
ccss_network <- ccss_network_1 %>%
  activate(nodes) %>%
  mutate(degree = centrality_degree(mode = "all")) %>%
  mutate(in_degree = centrality_degree(mode = "in"))

ccss_network
```

We now see that these simple measures of centrality have been added to
the nodes in our network.

### **ðŸ‘‰ Your Turn** **â¤µ**

As you may have noted above, we forgot to include out-degree in our
measures of centrality. Copy the code from above and add an out-degree
measure to each node and print the output:

```{r}
ccss_network <- ccss_network_1 %>%
  activate(nodes) %>%
  mutate(degree = centrality_degree(mode = "all")) %>%
  mutate(in_degree = centrality_degree(mode = "in")) %>%
  mutate(out_degree = centrality_degree(mode = "out"))

ccss_network
```

#### Summarize Centrality Measures

We can also use the `activate()` function combined with the
`data.frame()` function to extract our new measures to a separate data
frame so we inspect our nodes individually and create some summary
statistics using the handy `summary()` function.

```{r}
node_measures <- ccss_network %>% 
  activate(nodes) %>%
  data.frame()

summary(node_measures)
```

We see that typical nodes in this network are connected on average with
3 other Twitter users and have received on average mentions or replies
from 1.5 users.

### **ðŸ‘‰ Your Turn** **â¤µ**

Recall from the Prepare section that one of the questions guiding this
analysis was:

> Who are the transmitters, transceivers, and transcenders in our Common
> Core Twitter network?

Use the code chunk below to `view()` your `node_measures` data frame and
answer the questions that follow:

```{r, eval=FALSE}
view(node_measures)
```

Identify the Twitter user with the highest value for each of the
following types of central actors:

-   **Transmitters:**

-   **Transceivers:**

-   **Transcenders:**

## 3b. Make a Sociogram

If you recall from [1a. Review the Research] section, one of the
defining characteristics of the social network perspective is its use of
graphic imagery to represent actors and their relations with one
another. To emphasize this point, @carolan2014 reported that:

> The visualization of social networks has been a core practice since
> its foundation more than 90 years ago and remains a hallmark of
> contemporary social network analysis.Â 

Network visualization can be used for a variety of purposes, ranging
from highlighting key actors to even serving as works of art.

This excellent figure from Katya Ognyanova's also excellent tutorial on
[Static and Dynamic Network Visualization with
R](https://kateto.net/network-visualization/) helps illustrate the
variety of goals a good network visualization can accomplish:

![](img/viz-goals.jpeg){width="80%"}

These visual representations of the actors and their relations, i.e. the
network, are called a sociogram. Actors who are most central to the
network, such as those with higher node degrees, are usually placed in
the center of the sociogram and their ties are placed near them. As
we'll see in just a bit, those two actors with hundreds of ties will be
placed by most graph layout algorithms in the center of the graph.

### **ðŸ‘‰ Your Turn** **â¤µ**

The `plot()` function from R's built in {graphics} package can be used
to make a simple sociogram, but as you'll see, it's a bit lacking.

In the code chunk below, use the `plot()` function with your
`ccss_network` object to see what the basic plot function produces:

```{r}
plot(ccss_network)
```

If this had been a smaller network like one generated from a single
classroom, this might have been a little more useful, but for larger
networks like our Twitter data, this doesn't communicate much. In fact,
it's visualizations like these that give sociograms the unflattering
nickname of "hair ball" plots!

Fortunately, the {ggraph} package includes a plethora of plotting
parameters for graph
[layouts](https://ggraph.data-imaginist.com/articles/Layouts.html),
[edges](https://ggraph.data-imaginist.com/articles/Edges.html) and
[nodes](https://ggraph.data-imaginist.com/articles/Nodes.html) to
improve the visual design of network graphs.

For the remainder of this section, we're going to focus on creating a
sociogram that highlights the main "transmitters" in our network.

### Build a network

One thing to keep in mind when building a network viz with {ggraph}, is
that just like it's `ggplot()` counterpart, the `ggraph()` function
takes care of setting up the plot object along with creating the layout
for the plot based on the network object and the layout specification
provided.

Let's first pass our `ccss_network` object to ggraph and see what
happens.

```{r}
ggraph(ccss_network)
```

As you can see, just like the `ggplot()` function, this didn't produce
much on it's own. All that the `ggraph()` function does is set up the
network object to make a sociogram, and create a layout for our network,
in this case the default "stress" layout.

#### Add Nodes

Very similar to how `ggplot()` uses the `+` operator to "layer"
functions together to progressively build graphs, `ggraph` use the `+`
operator progressively build a sociogram.

To add our nodes, we'll added the `geom_node_point()` function. Again,
just like with {ggplot2}, the "geom" in the `geom_non_point()` functions
stands for "Geometric elements", or geoms for short, and represents what
you actually see in the plot.

### **ðŸ‘‰ Your Turn** **â¤µ**

Now "add" the `geom_node_point()` function to our code using the `+`
operator:

```{r}
ggraph(ccss_network) + 
  geom_node_point() 
```

Well, at least we have our nodes now! But the default "stress" layout
for our sociogram is not so great. Let's fix that.

#### Add Layout

One of the major advances in visualization since the first hand-drawn
sociograms developed by Jacob Moreno (1934) to represent relations among
children in school is the use of software and algorithms to
automatically layout networks on a grid.

There are may different [layout
methods](https://en.wikipedia.org/wiki/Graph_drawing#Layout_methods),
but we'll start with the Fruchterman-Reingold (FR) layout, which is one
of the most used layout algorithms for network visualization. These
types of force-directed algorithms generally work well with large
networks and try to layout graphs in "an aesthetically-pleasing way" by
making edges roughly equal in length and minimizing overlap.

Let's go ahead and include the layout argument, which in addition to
including its own unique layouts, can incorporate layouts form {igraph}
package like `fr` for the Fruchterman-Reingold (FR) layout:

```{r}
ggraph(ccss_network, layout = "fr") +
  geom_node_point()
```

That's a little better. We can also start to make out our separate
network "components" as distinct groups, with one larger connected group
in the center. In our Model section, we'll introduce community detection
algorithms to automatically identify groups and use color to show group
membership.

#### Tweak Nodes

Also like {ggplot2}, geoms can include aesthetics, or aes for short,
such as `alpha` for transparency, as well as `color`, `shape` and
`size`.

Let's now add some "aesthetics" to our points by including the `aes()`
function and arguments such as `size =` and `color =`, which we can set
to our `out_degree` measures to help highlight our primary transmitters:

```{r}
ggraph(ccss_network, layout = "fr") + 
geom_node_point(aes(size = out_degree,
                    color = out_degree))
```

We can clearly see we have one main transmitter in this network!
Unfortunately, without labels we don't know who this Twitter users is.

Let's fix that by adding another layer with some node text and labels.
Since node labels are a geometric element, we can apply aesthetics to
them as well, like color and size. Let's also include the `repel =`
argument that when set toÂ `TRUE`Â will avoid overlapping text.

```{r}
ggraph(ccss_network, layout = "fr") + 
  geom_node_point(aes(size = out_degree,
                      color = out_degree)) +
  geom_node_text(aes(label = actors,
                     size = out_degree/2,
                     color = out_degree),
                 repel=TRUE)
```

Much better! Even without the edges, using size and color have helped to
highlight the main "transmitter" in our network.

#### Add Edges

Now, let's connect the dots and add some
[edges](https://ggraph.data-imaginist.com/articles/Edges.html) using the
`geom_edge_link()` function. We'll also include some arguments like
`arrow =` to include some arrows 1mm in length, an `end_cap =` around
each node to keep arrows from overlapping the them, and set the
transparency of our edges to `alpha = .2` so our edges fade more into
the background and help keep the focus on our nodes:

```{r}
ggraph(ccss_network, layout = "fr") + 
  geom_node_point(aes(size = out_degree,
                      color = out_degree)) +
  geom_node_text(aes(label = actors,
                     size = out_degree/2,
                     color = out_degree),
                 repel=TRUE) +
  geom_edge_link(arrow = arrow(length = unit(1, 'mm')), 
                 end_cap = circle(3, 'mm'),
                 alpha = .2)
```

#### Add a Theme

Finally, let's add a **theme,** which controls the finer points of
display, like the font size and background color. The `theme_graph()`
function add a theme specially tuned for graph visualizations. This
function removes redundant elements in order to put focus on the data
and if you type `?theme_graph` in the console you will get a sense of
the level of fine tuning you can do if desired.

Let's add `theme_graph()` to our sociogram, remove the legends since
they are not especially useful, and call it good for now:

```{r}
ggraph(ccss_network, layout = "fr") + 
  geom_node_point(aes(size = out_degree,
                      color = out_degree),
                  show.legend = FALSE) +
  geom_node_text(aes(label = actors,
                     size = out_degree/2,
                     color = out_degree),
                 repel=TRUE,
                 show.legend = FALSE) +
  geom_edge_link(arrow = arrow(length = unit(1, 'mm')), 
                 end_cap = circle(3, 'mm'),
                 alpha = .2) + 
  theme_graph()
```

**Note:** If you're having difficulty seeing the sociogram in the small
R Markdown code chunk, you can copy and paste the code in the console
and it will show in the viewpane and then you can enlarge and even save
as an image file.

### **ðŸ‘‰ Your Turn** **â¤µ**

Try modifying the code below by tweaking the included function/arguments
or adding new ones for
[layouts](https://ggraph.data-imaginist.com/articles/Layouts.html),
[nodes](https://ggraph.data-imaginist.com/articles/Nodes.html), and
[edges](https://ggraph.data-imaginist.com/articles/Edges.html) to
highlight the main "transenders" or "tranceivers" in our network. See if
you can also make your plot either more "aesthetically pleasing" and/or
more purposeful in what it's trying to communicate.

There are no right or wrong answers, just have some fun trying out
different approaches!

```{r}
ggraph(ccss_network, layout = "fr") + 
  geom_node_point(aes(size = out_degree,
                      color = out_degree),
                  show.legend = FALSE) +
  geom_node_text(aes(label = actors,
                     size = out_degree/2,
                     color = out_degree),
                 repel=TRUE,
                 show.legend = FALSE) +
  geom_edge_link(arrow = arrow(length = unit(1, 'mm')), 
                 end_cap = circle(3, 'mm'),
                 alpha = .2) + 
  theme_graph()
```

Congrats! You made it to the end of the Explore section and are ready to
learn a little about network modeling! Before proceeding further, knit
your document and check to see if you encounter any errors.

------------------------------------------------------------------------

## 4. MODEL

As highlighted inÂ [Chapter 3 of Data Science in Education Using
R](https://datascienceineducation.com/c03.html), theÂ **Model**Â step of
the data science process entails "using statistical models, from simple
to complex, to understand trends and patterns in the data." We will not
explore the use of models for SNA until Lab 4, but recall from the
PREPARE section that to assess agreement between perceived friendships
by the teacher and students, [@pittinsky2008behavioral] note that:

> **The QAP (quadratic assignment procedure)** [is] used to calculate
> the degree of association between two sets of relations and tests
> whether the probability of dyad overlap in the teacher matrix is
> correlated with the probability of dyad overlap in the student matrix.
> It does so by running a large number of simulations. These simulations
> generate random matrices with sizes and value distributions based on
> the original two matrices being tested.

We will learn more about the QAP and other models for statistical
inference when working with relational data in Learning Lab 4.

------------------------------------------------------------------------

## 5. COMMUNICATE

Our goal is to distill the analysis from above into a simple "data
product" designed to illustrate key findings about changes in the
collaboration network over time. For the purposes of this task, imagine
that your audience consists of teachers and school leaders who have
limited background in SNA and adapt the following steps accordingly:

1.  **Select.** Select our sociogram from above, or create a entirely
    new sociogram if so motivated, that you think would be interesting
    or relevant for the target audience and that helps answer our
    research questions.

2.  **Polish.** Create a visually attractive sociogram to help
    illustrate similarities and differences in classroom friendships
    reported by teachers and students.

3.  **Narrate.** Write a brief narrative to accompany your visualization
    and/or table that includes the following:

    -   The question or questions guiding the analysis;

    -   The conclusions you've reached based on our findings;

    -   How your audience might use this information;

    -   How you might revisit or improve upon this analysis in the
        future.

### ðŸ‘‰ Your Turn â¤µ

Use the code chunk below create a polished table and/or visualization(s)
and write a brief narrative in the space that follows.

### Data Visualization or Table

```{r create_data_product}
# YOUR CODE HERE


```

### Narrative

NARRATIVE GOES HERE...

### ðŸ§¶ Knit & Check âœ…

Congratulations - you've completed the Lab 4 case study! One final step
is to "Knit" your document by clicking the drop down arrow next to the
ball of yarn in the menu bar an that the top of this markdown file, and
then selecting "Knit top HTML" or another preferred output format. This
will do two things: 1) it will check through all your code for any
errors, 2) it will created a file in your directory that you can use to
share you work through [GitHub Pages](https://pages.github.com),
[RPubs](https://rpubs.com/about/getting-started), or any other preferred
means.

### References
