---
title: 'Network Measures & Sociograms'
subtitle: 'SNA Learning Lab 2'
author: "LASER Institute"
date: "`r format(Sys.Date(),'%B %e, %Y')`"
output:
  html_document:
    toc: yes
    toc_depth: 5
    toc_float: yes
  html_notebook:
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 3. EXPLORE

As noted in the Getting Started Walkthrough, exploratory data analysis involves the processes of describing your data (such as by calculating the means and standard deviations of numeric variables, or counting the frequency of categorical variables) and, often, visualizing your data prior to modeling.

In Learning Lab 2, we pickup right where we left off with our data wrangling. We'll learn some new functions for retrieving basic network descriptives related to our research question and use some of these metrics to create and refine a network visualization that helps illustrate key findings. Specifically, in this section we'll learn to:

a.  **Examine Basic Descriptives**. We focus primarily on actors and edges in this walkthrough, including the edges wights we added in the previous section as well as node degree, and import and fairly intuitive measure of centrality.

b.  **Make a Sociogram**. Finally, we wrap up the explore phases by learning to plot a network and tweak key elements like the size, shape, and position of nodes and edges to better at communicating key findings.

Before we explore, let's reload our libraries from the previous lab since we're working in a new

```{r}
library(igraph)
```

**RStudio Tip:** We has another reason for reviewing and running our code...\

### 3a. Examine Basic Descriptives

Many analyses of social networks are primarily descriptive. As Carolyn (2013) notes that these descriptive studies aim either to represent the network's underlying social structure through data-reduction techniques or to characterize network properties through network measures.

#### Node Degree

A key structural property of networks is the concept of centralization. A network that is highly centralized is one in which relations are focused on a small number of actors or even a single actor in a network, whereas ties in a decentralized network are diffuse and spread over a number of actors. One of the most common descriptives reported in network studies and a primary measure of centralization is **degree**.

> Degree is the number of ties to and from an ego. In a directed network, in-degree is the number of ties received, whereas out-degree is the number of ties sent.

The {igraph} package has an aptly named function `degree()` for retrieving degree, in-degree, and out-degree for all actors in a network.

Run the following code to extract measures and save to `node_degree` which we'll examine in just a bit:

```{r}
node_degree <- degree(weighted_network, mode = "all")
```

**Note**. We set the `mode =` argument in this function to "all" which give us the total number of participants that each actor in our network with sent or received a reply.

Let's take a look at the distribution of `node_degree` in our network by using R's built in `hist()` function for creating histograms. I set the value of `breaks =`, or bins in our histogram, to 30 since I already know some actors in this network have a very high degree.

```{r}
hist(node_degree, breaks = 30)
```

We can see that most actors in the network are connected to very few individuals while a couple actors in this network are connected to a very larger number, nearly 200 and 350 respectively!

Now let's take a look at the mean and median for `node_degree` using some other {base} R functions:

```{r}
mean(node_degree)
median(node_degree)
```

We see that the mean suggests the participants are, on average, connected to about 8 other participants in the MOOC-Ed, but this is likely heavily skewed by the two individuals with a disproportionate number of connections. The median is probably a better characterization of the typical number of educators a participant has sent or received a reply.

##### In-Degree

Let's go ahead and take a look at in-degree next:

```{r}
in_degree <- degree(weighted_network, mode="in")

hist(in_degree, breaks = 30)
mean(in_degree)
median(in_degree)
```

Again, most participants received a reply from small number of individuals.

### **ðŸ‘‰ Your Turn** **â¤µ**

Use the code chunk below to examine the distribution, mean and median of `out_degree`:

```{r}

```

In the space below, write your interpretation of these results.

\-

#### Edge Weights

Finally, let's also take a look at the distribution, mean and median of the edge weights we added to our graph.

Recall from earlier that the {igraph} package has a unique syntax for accessing node and edge attributes. For edges we use `E()` and included the name of the network object we want to use, followed by the `$` operator to select the attribute.

```{r}
weights <- E(weighted_network)$weight

hist(weights, breaks = 10)
mean(weights)
median(weights)

```

It looks like the vast majority or participants either sent or received a reply from just one other participant.

### **ðŸ‘‰ Your Turn** **â¤µ**

The use of the `$` is actually standard across R and a very useful operator.

Use the code chunk below to create a histogram and calculate the mean and median from the edge weighs created earlier in the [Add Edge Weights] section by using the `edge_weights` data frame, the `$` operator, and column `n` which contains the counts for each unique edge.

```{r}

```

Are these results consistent with our summary of edge weights we created above?

\-

## 3b. Make a Sociogram

If you recall from our [1a. Review the Research] section, one of the defining characteristics of the social network perspective is its use of graphic imagery to represent actors and their relations with one another. To emphasize this point, Carolyn (2013) reported that:

> The visualization of social networks has been a core practice since its foundation more than 90 years ago and remains a hallmark of contemporary social network analysis.Â 

Network visualization can be used for a variety of purposes, ranging from highlighting key actors to even serving as works of art. This excellent figure from Katya Ognyanova's also excellent tutorial on [Static and Dynamic Network Visualization with R](https://kateto.net/network-visualization/) helps illustrate the variety of goals a good network visualization can accomplish:

![](img/viz-goals.jpeg){width="80%"}

These visual representations of the actors and their relations, i.e. the network, are called a sociogram. Actors who are most central to the network, such as those with higher node degrees, are usually placed in the center of the sociogram and their ties are placed near them. As we'll see in just a bit, those two actors with hundreds of ties will be placed by most graph layout algorithms in the center of the graph.

For Unit 1, we'll be using the `plot()` function from R's built in {graphics} package to make a sociogram.

Let's run the code and see what we get without any tweaking and see what the plot function produces:

```{r}
plot(weighted_network)

```

If this had been a smaller network like one generated from a teacher professional development workshop, this might have been useful, but for large networks like our MOOC-Ed discussion forums, this doesn't communicate much. In fact, it's visualizations like these that give sociograms the unflattering nickname of "hair ball" plots.

Fortunately, the {igraph} package includes a [plethora of plotting parameters](https://igraph.org/r/doc/plot.common.html) for improving the layout and visual design of network graphs!

There are many ways to modify vertices and edges in a sociogram to improve readability. Up to four attributes of each actor can be layered onto the sociogram by altering the color, shape, label, and size of the symbol. And attributes for edges can be represented in a range of ways as well.

### Remove Labels

One quick fix is to simply remove the labels by adding the `vertex.label =` argument and setting it to `NA`.

Since the number labels don't provide much useful information, let's go ahead and remove them:

```{r}
plot(weighted_network,
     vertex.label = NA)
```

We can now at least see the nodes, or vertices, but with 445 participants in the forums, many are masked by the default size of each node.

### Change vertex size

By default, the size of nodes is 15. Let's add the `vertex.size =` argument and change that to 1:

```{r}
plot(weighted_network,
     vertex.label = NA,
     vertex.size = 1)
```

A little better, but let's use the `node_degree` we calculated to emphasize those wiht greater connections in the course by substitute `node_degree` for a specific value.

```{r}
plot(weighted_network,
     vertex.label = NA,
     vertex.size = node_degree)
```

Whoops! This certainly emphasizes the disproportionate number of ties among these two participants, but not quite what we're going for.

Since `node_degree` is just a list of values for each node we can treat it like a number. Let's divide that by 10 to reduce the relative size:

```{r}
plot(weighted_network,
     vertex.label = NA,
     vertex.size = node_degree/10)
```

That's better, and helps highlight our two main actors without overshadowing the rest, but those arrows are definitely an eyesore.

### Reduce arrow size

Let's add the `edge.arrow.size =` argument and dramatically reduce:

```{r}
plot(weighted_network,
     vertex.label = NA,
     vertex.size = node_degree*.1,
     edge.arrow.size = .04)
```

Much better, now let's deal with the size of the edges.

#### Adjust Edge Width

We can add the `edge.width =` argument to help minimize edge overlap yet still make them visible. This is a bit of trial and error but let's give .2 a try since the default is 1:

```{r}
plot(weighted_network,
     vertex.label = NA,
     vertex.size = node_degree*.05,
     edge.arrow.size = .04,
     edge.width = .2)
```

Note that we could also set `edge.with =` to the weight of each edge, similar to how we used degree for the size of each node.

Let's give that a try:

```{r}
plot(weighted_network,
     vertex.label = NA,
     vertex.size = node_degree*.1,
     edge.arrow.size = .04,
     edge.width = E(weighted_network)$weight)
```

Not much of an improvement, if at all, given how many edges are in our network.

Let's try dividing that weight by 5 similar to reduce like with did with the `vertex.size =` argument:

```{r}
plot(weighted_network,
     vertex.label = NA,
     vertex.size = node_degree*.05,
     edge.arrow.size = .05,
     edge.width = E(weighted_network)$weight/5)
```

Better, but since we know most edges have a weight of 1 there really isn't too much to work with here.

Let's move on to changing graph layout!

#### Change Layout

One of the major advances in visualization since the first hand-drawn sociograms developed by Jacob Moreno (1934) to represent relations among children in school is the use of software and algorithms to automatically layout networks on a grid.

There are may different [layout methods](https://en.wikipedia.org/wiki/Graph_drawing#Layout_methods), but we'll start with the Fruchterman-Reingold (FR) layout, which is one of the most used layout algorithms for network visualization. These types of force-directed algorithms generally work well with large networks and try to layout graphs in "an aesthetically-pleasing way" by making edges roughly equal in length and minimizing overlap.

Let give the FR layout a try by using the `layout =` argument and specifying `layout_with_fr`:

```{r}
plot(weighted_network,
     vertex.label = NA,
     vertex.size = node_degree*.05,
     edge.arrow.size = .05,
     edge.width = E(weighted_network)$weight/5,
     layout = layout_with_fr)
```

By default, {igraph} uses `layout_nicely`, a smart function that chooses a layout based on the graph. Given the similarity with our previous graph, I'm assuming it chose the the FR layout as well.

Let's try one more just for fun:

```{r}

plot(weighted_network,
     vertex.label = NA,
     vertex.size = node_degree*.05,
     edge.arrow.size = .05,
     edge.width = E(weighted_network)$weight/5,
     layout = layout_in_circle)

```

Interesting but not terribly useful!

There are many other [igraph layout functions](https://igraph.org/r/doc/layout_.html), some more useful than others depending on the context. We've only scratched the surface of what's possible with network plotting but hopefully this have given you a sense of what required to avoid the dreaded "hair ball" plot and create a network viz that communicates something useful.

### **ðŸ‘‰ Your Turn** **â¤µ**

Try modifying the code below by tweaking the included arguments/parameters or [adding new arguments/parameters](https://igraph.org/r/doc/plot.common.html) to make our plot either more "aesthetically pleasing" or more purposeful in what it's trying to communicate.

There are no right or wrong answers, just have some fun trying out different approaches!

```{r}
# plot(weighted_network,vertex.label = NA,
#      vertex.size = node_degree*.05,
#      edge.arrow.size = .05,
#      edge.width = E(weighted_network)$weight/5,
#      layout = layout_with_fr)


```

### ðŸ§¶ Knit & Check âœ…

Congrats! You made it to the end of the SNA Learning Lab 2 and are ready to learn a little about network modeling! Before proceeding further, knit your document and check to see if you encounter any errors.

## ðŸŽ‰ Reach 

You're also welcome to try out some of the other graphing options from from Katya Ognyanova's tutorial on [Static and Dynamic Network Visualization with R](https://kateto.net/network-visualization/).

## REFERENCES
